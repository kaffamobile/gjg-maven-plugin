package io.github.kaffamobile.tools.maven.gjg

import org.apache.maven.plugin.logging.Log
import java.io.File
import java.nio.file.Paths
import java.time.LocalDateTime
import kotlin.io.path.deleteIfExists

class GjgHandler(
    private val log: Log,
    private val baseDir: File,
    private val arch: String,
    private val outputFile: String,
    private val jarFile: String?,
    private val javaDir: String?,
    private val jvmArgs: List<String>,
    private val appArgs: List<String>,
    private val env: Map<String, String>,
    private val icon: String?,
    private val fileDescription: String?,
    private val productName: String?,
    private val productVersion: String?,
    private val companyName: String?,
    private val copyright: String?,
) : Runnable {
    override fun run() {
        val outputGjgExeFile = Paths.get(this.outputFile).toAbsolutePath().toFile()
        val outputGjgConfFile = File(outputGjgExeFile.parentFile, "${outputGjgExeFile.nameWithoutExtension}.gjg.conf")

        extractGjg(outputGjgExeFile)
        setIconAndMetadatas(outputGjgExeFile)
        createConf(outputGjgConfFile, outputGjgExeFile)
    }

    private fun extractGjg(outputGjgExeFile: File) {
        val resource = when (arch.lowercase()) {
            "amd64", "x86_64" -> "/bin/gjg-launcher-windows-amd64.exe"
            "386", "x86" -> "/bin/gjg-launcher-windows-386.exe"
            "arm64" -> "/bin/gjg-launcher-windows-arm64.exe"
            else -> error("Unsupported arch: $arch")
        }
        extractResource(resource, outputGjgExeFile)
    }

    private fun setIconAndMetadatas(outputExe: File) {
        val rcEditFile = File(outputExe.parentFile, "rcedit-x64.exe")
        extractResource("/bin/rcedit-x64.exe", rcEditFile)
        try {
            runRcEdit(rcEditFile, outputExe)
        } finally {
            rcEditFile.delete()
            rcEditFile.deleteOnExit()
        }
    }

    private fun runRcEdit(rcEditFile: File, outputExe: File) {
        val mainCommand = if (System.getProperty("os.name").lowercase().contains("win")) {
            listOf(rcEditFile.absolutePath, outputExe.absolutePath)
        } else {
            check(isWineAvailable()) { "wine is required to use this plugin on Linux" }
            listOf("wine", rcEditFile.absolutePath, outputExe.absolutePath)
        }

        val args = listOfNotNull(
            listOf("--set-icon", icon?.findIconPath()).takeIf { icon != null },
            listOf("--set-version-string", "FileDescription", fileDescription).takeIf { fileDescription != null },
            listOf("--set-version-string", "ProductName", productName).takeIf { productName != null },
            listOf("--set-version-string", "CompanyName", companyName).takeIf { companyName != null },
            listOf("--set-version-string", "LegalCopyright", copyright).takeIf { copyright != null },
            listOf("--set-file-version", productVersion).takeIf { productVersion != null },
            listOf("--set-product-version", productVersion).takeIf { productVersion != null },
        ).flatten().filterNotNull()

        val fullCmd = mainCommand + args
        log.info("Running rcedit: ${fullCmd.joinToString(" ")}")

        val process = ProcessBuilder(fullCmd).inheritIO().start()
        val exit = process.waitFor()

        check(exit == 0) {
            "rcedit failed with exit code $exit"
        }
    }

    private fun createConf(configFile: File, outputGjgExeFile: File) {
        val lines = listOfNotNull(
            "java_dir=$javaDir".takeIf { javaDir != null },
            "jar_file=$jarFile".takeIf { jarFile != null },
            "jvm_args=${jvmArgs.joinToArg()}".takeIf { jvmArgs.isNotEmpty() },
            "app_args=${appArgs.joinToArg()}".takeIf { appArgs.isNotEmpty() },
            *env.map { (k, v) -> "env_$k=$v" }.toTypedArray()
        )

        configFile.delete()
        configFile.writer().use { writer ->
            writer.write("""
                # =============================================
                #  GJG Launcher Configuration - Maven plugin
                #  Generated by gjg-maven-plugin
                #  Date: ${LocalDateTime.now()}
                # =============================================
            """.trimIndent())

            writer.appendLine()
            lines.forEach(writer::appendLine)
        }
    }

    private fun extractResource(resource: String, target: File) {
        target.toPath().deleteIfExists()
        this::class.java.getResourceAsStream(resource)?.use { input ->
            target.outputStream().use { output -> input.copyTo(output) }
        }
        check(target.exists()) {
            "Error copying $resource file from resources to output $target"
        }
    }

    private fun isWineAvailable(): Boolean {
        return runCatching { ProcessBuilder("wine", "--version").start().waitFor() == 0 }.getOrElse { false }
    }

    private fun String.findIconPath(): String {
        val alreadyFound = File(this)
        if (alreadyFound.exists()) {
            return alreadyFound.absolutePath
        }
        return baseDir.walkTopDown()
            .firstOrNull { it.name == this }
            ?.absolutePath
            ?: throw RuntimeException("icon $this not found, provide the relative or the absolute path")
    }

    private fun List<String>.joinToArg(): String {
        return this.joinToString(" ") { it.trim() }
    }
}